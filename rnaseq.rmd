# RNA-seq

### Loading the data

Dataset obtained from a study to identify prognostic signature of colorrectal cancer (CRC) patients.
The data was obtained from the NCBI Sequence Read Archive (SRA) under the accession number SRP029880.
RNA-seq data was generated using 54 samples (normal colon, primary CRC, and liver metastasis) obtained from 
18 patients. The data was then used to to identify significant genes associated with CRC progression.

```{r}
counts_file <- system.file("extdata/rna-seq/SRP029880.raw_counts.tsv",
                           package = "compGenomRData")
coldata_file <- system.file("extdata/rna-seq/SRP029880.colData.tsv",
                            package = "compGenomRData")

counts <- as.matrix(read.table(counts_file, header = T, sep = '\t'))
```
### Computing CPM
```{r}
summary(counts[,1:3])

# Computing cpm for each sample
cpm <- apply(subset(counts, select = c(-width)), 2,
             function(x) x / sum(as.numeric(x)) * 10^6)

# Diplaying results across all samples
colSums(cpm)
```

### Computing RPKM
```{r}
geneLengths <- as.vector(subset(counts, select = c(width)))

# Compute rpkm
rpkm <- apply(X = subset(counts, select = c(-width)), 
              MARGIN = 2,
              FUN = function(x) {
                  10^9 * x / geneLengths / sum(as.numeric(x))
                })

# Diplaying results across all samples
colSums(rpkm)
```

### Computing TPM
```{r}
# Gene lengths normalized values
rpk <- apply( subset(counts, select = c(-width)), 2,
              function(x) x / (geneLengths / 1000))

# Normalize by sample size using rpk
tpm <- apply(rpk, 2, function(x) x / sum(as.numeric(x)) * 10^6)

# Diplaying results across all samples
colSums(tpm)
```

### Clustering
```{r}
# Computing variance across samples
variance <- apply(tpm, 1, var)

# Sorting by decreasing variance and selecting the top 100 genes
selectedGenes <- names(variance[order(variance, decreasing = T)][1:100])

# Creating a heatmap of gene/sample clustering
library(pheatmap)
pheatmap(tpm[selectedGenes,], scale = "row", show_rownames = F)

# Recreating the heatmap with some annotation of the various attributes
colData <- read.table(coldata_file, header = T, sep = '\t',
                      stringsAsFactors = T)
pheatmap(tpm[selectedGenes,], scale = "row",
         show_rownames = F,
         annotation_col = colData)
```

### PCA plotting
```{r}
library(stats)
library(ggplot2)
# Obtaining tranpose of the matrix
M <- t(tpm[selectedGenes,])

# Transform to log2 scale
M <- log2(M + 1)

# Calculating PCA
pcaResults <- prcomp(M)

# Plotting the PCA
autoplot(pcaResults, data = colData, colour = "group")

# Returning a summary of the PCA
summary(pcaResults)
```

### Correlation plots
```{r}
corrMatrix <- cor(tpm)

# Plotting the correlation matrix
library(corrplot)
corrplot(corrMatrix, method = "circle",
         addrect = 2, addCoef.col = "white",
         number.cex=0.7)

# Replotting the correlation using a heatmap
pheatmap(corrMatrix, annotation_col = colData,
         cutree_cols = 2)
```

### Differential expression analysis
* Allows for testing tens of thousands of hypotheses against the null hypothesis that the activity
  of the gene stays the same in two different conditions.
* Model assumes that for each gene, the read counts are generated by negative binomial distribution 

```{r}
# Loading the DESeq2 package
library(DESeq2)

# Removing width column from original counts matrix
countData <- as.matrix(subset(counts, select = c(-width)))

# Defining design formula
designFormula <- "~ group"

# Creating DESeq2 object
dds <- DESeqDataSetFromMatrix(countData = countData,
                              colData = colData,
                              design = as.formula(designFormula))
# Printing dds object
print(dds)

# rownames(dds) displays the gene names
# colData(dds) displays the sample information
# counts(dds) displays the raw counts
# colData(dds) displays experimental setup

# Removing genes that contain at least 1 read
dds <- dds[rowSums(DESeq2::counts(dds)) > 1,]

# Creating DESeqDataSet object using DESeq()
dds <- DESeq(dds)

# Printing results
DEresults <- results(dds, contrast = c("group", "CASE", "CTRL"))

# Sorting results by increasing p-value and printing them
DEresults <- DEresults[order(DEresults$pvalue),]
print(DEresults)
```

First 3 lines show statistical tests used to calculate the results and dimensions of the results table.
baseMean represents the average normalzied expression of the gene across all considered samples.
log2FoldChange respresents the log2 fold change of the normalized expression of the gene.
lfcSE represents the standard error of the log2 fold change.
stat is the statistics calculated in the test which translates to p-value

### Downstream Analysis
* Tests to imrpove confidence about quality of the data and the experimental design

MA plot is used to observe if data normalization was successful. X-axis represents the average of the 
normalized counts across samples and y-axis denotes the log fold change.
```{r}
DESeq2::plotMA(dds, ylim = c(-5, 5))
```

A RLE (relative log expression) plot is useful to find out if the data needs to be normalized.
```{r}
library(EDASeq)

par(mfrow = c(1, 2))

# Creating RLE plots
plotRLE(countData, outline=F, ylim=c(-4, 4),
        col=as.numeric(colData$group),
        main = "Raw counts")
plotRLE(DESeq2::counts(dds), normalized = T,
        outline=F, ylim=c(-4, 4),
        col = as.numeric(colData$group),
        main = "Normalized counts")
```

### Function Enrichment Analysis
* Gene Ontology Consortium has collected Gene Ontology (GO) terms for each gene.
* GO term analysis helps quickly find out systematic changes that can describe differences between groups
  of samples.

```{r}
library(gProfileR)
library(knitr)

# Getting the DEresults again
DEresults <- results(dds, contrast = c("group", "CASE", "CTRL"))

# Removing NA values
DE <- DEresults[!is.na(DEresults$padj),]

# Selecting genes with adjusted p-value < 0.1 and log2 fold change > 1
DE <- DE[abs(DE$log2FoldChange) > 1 & DE$padj < 0.1,]

# Getting the gene names
genes <- rownames(DE)

# Calculating the GO enrichment terms
goResults <- gprofiler(query = genes,
                       organism = "hsapiens",
                       src_filter = "GO",
                       hier_filtering = "moderate")


# Ordering results by increasing p-value
goResults <- goResults[order(goResults$p.value),]

# Keeping terms that have the most out of 100 overlapping genes
go <- goResults[goResults$overlap.size < 100,]

# Using top term to create gene set
geneSet1 <- unlist(strsplit(go[1,]$intersection, ","))

# Creating another gene set using 25 randomly selected genes
normalizedCounts <- DESeq2::counts(dds, normalized = T)
geneSet2 <- sample(rownames(normalizedCounts), 25)

# Creating a list of gene sets
geneSets <- list( "top_GO_term" = geneSet1,
                  "random_genes" = geneSet2)

# Creating group comparison between case samples and control samples
library(gage)
gseaResults <- gage(exprs = log2(normalizedCounts + 1),
            ref = match(rownames(colData[colData$group == "CTRL",]),
                        colnames(normalizedCounts)),
            samp = match(rownames(colData[colData$group == "CASE",]),
                         colnames(normalizedCounts)),
            gsets = geneSets, compare = "as.group")

print(gseaResults$greater)
print(gseaResults$less)

# Creating a heatmap visualizing no sigificant up- or down-regulation of genes 
M <- normalizedCounts[rownames(normalizedCounts) %in% geneSet1,]

# log transform counts for visualization

pheatmap(log2(M+1),
         annotation_col = colData,
         show_rownames = T,
         fontsize_row = 8,
         scale = "row",
         cutree_cols = 2,
         cutree_rows = 2)
```

### Accounting for sources of variation
```{r}
# Using a subset fo the count table obtained for a heart disease survey
counts_file <- system.file('extdata/rna-seq/SRP021193.raw_counts.tsv', 
                           package = 'compGenomRData')
colData_file <- system.file('extdata/rna-seq/SRP021193.colData.tsv', 
                            package = 'compGenomRData')

counts <- read.table(counts_file)
colData <- read.table(colData_file, header = T, sep = '\t', 
                      stringsAsFactors = TRUE)

# First examining how the samples cluster by calculating tpm counts
geneLengths <- counts$width
rpk <- apply(subset(counts, select=c(-width)), 2,
             function(x) x / (geneLengths / 1000))

# Normalize by sample size using rpk values
tpm <- apply(rpk, 2, function(x) x / sum(as.numeric(x)) * 10^6)

selectedGenes <- names(sort(apply(tpm, 1, var),
                            decreasing = TRUE))[1:100]

# Creating heatmap
pheatmap(tpm[selectedGenes,],
         annotation_col = colData,
         show_rownames = F,
         scale = "row")
```

